import jmespath

import demistomock as demisto
from CommonServerPython import *
from JSONFeedApiModule import *  # noqa: E402

# from Packs.ApiModules.Scripts.JSONFeedApiModule.JSONFeedApiModule import *
DEFAULT_LIMIT = 100
DEFAULT_COUNT = 10

SEARCH_PARAMS = {
    'indicator': 'indicator',
    'from': 'from',
    'until': 'until',
    'threat_type': 'threatType',
    'malware_family': 'malwareFamily',
    'confidence': 'confidence',
    'count': 'count',
}

FEED_INDICATOR_TYPES = {
    FeedIndicatorType.URL: FeedIndicatorType.URL,
    FeedIndicatorType.File: FeedIndicatorType.File,
    "ipv4": FeedIndicatorType.IP
}

FEED_URL = 'https://api.intel471.com/v1/indicators/stream?'
MAPPING = {
    FeedIndicatorType.File: {
        'threat_type': 'threattypes.threatcategory',
        'threat_data_family': 'malwarefamily',
        'indicator_data_file_md5': 'md5',
        'indicator_data_file_sha1': 'sha1',
        'indicator_data_file_sha256': 'sha256',
        'context_description': 'description',
        'indicator_data_file_download_url': 'downloadurl',
        'mitre_tactics': 'mitretactics',
    },

    FeedIndicatorType.URL: {'threat_type': 'threattypes.threatcategory',
                            'threat_data_family': 'malwarefamily',
                            'indicator_data_url': 'url',
                            'context_description': 'description',
                            'mitre_tactics': 'mitretactics',
                            },

    "ipv4": {'threat_type': 'threattypes.threatcategory',
             'threat_data_family': 'malwarefamily',
             'indicator_data_address': 'ipaddress',
             'context_description': 'description',
             'mitre_tactics': 'mitretactics',
             }

}
INDICATOR_VALUE_FIELD = {FeedIndicatorType.File: 'indicator_data_file_sha256',
                         FeedIndicatorType.URL: 'indicator_data_url',
                         "ipv4": 'indicator_data_address'}


def _create_url(**kwargs):
    url_suffix = ""
    for param in kwargs:
        url_suffix += f"&{param}={kwargs.get(param)}"
    return FEED_URL + url_suffix.strip('&')


def _build_url_parameter_dict(**kwargs):
    """
    Given a set of parameters, creates a dictionary with only searchable items that can be used in api.
    """
    params_dict = {}
    for param in kwargs:
        if param in SEARCH_PARAMS:
            params_dict[SEARCH_PARAMS.get(param)] = kwargs.get(param)

    return params_dict


def get_params_by_indicator_type(**kwargs):
    indicators_url = {}
    params = _build_url_parameter_dict(**kwargs)
    params['count'] = min(int(params.get('count', DEFAULT_COUNT)), DEFAULT_LIMIT)
    if kwargs.get('cursor'):
        set_integration_context({'next_cursor': kwargs.get('cursor')})
    if 'search_indicator_type' in kwargs:
        indicator_type = kwargs.get('search_indicator_type')
        params['indicatorType'] = indicator_type
        indicators_url[indicator_type] = _create_url(**params)
    else:
        for indicator_type in FEED_INDICATOR_TYPES:
            params['indicatorType'] = indicator_type
            indicators_url[indicator_type] = _create_url(**params)

    return indicators_url


def custom_build_iterator(client: Client, feed, **kwargs) -> List:
    result = []
    should_continue = True
    limit = int(feed.get('results_limit'))
    url = feed.get('url', client.url)
    cursor = get_integration_context()
    cursor_param = f"&cursor={cursor.get('next_cursor')}" if cursor else ''

    while should_continue:

        r = requests.get(
            url=url + cursor_param,
            verify=client.verify,
            auth=client.auth,
            cert=client.cert,
            headers=client.headers,
            **kwargs
        )
        try:
            r.raise_for_status()
            data = r.json()
            current_result = jmespath.search(expression=feed.get('extractor'), data=data)

            if current_result:  # handles the last query
                result = result + current_result

            # should only continue while there are results and didn't reach the limit set by user.
            should_continue = True if limit > len(result) and len(data.get('indicators', [])) > 0 else False

            # saves next page reference in context, if all results were looped on then start again.
            if data.get('cursorNext') == cursor.get('next_cursor'):
                should_continue = False  # should happen because no indicators list is found but making sure.
                set_integration_context({})
            else:
                set_integration_context({'next_cursor': data.get('cursorNext')})

        except ValueError as VE:
            raise ValueError(f'Could not parse returned data to Json. \n\nError massage: {VE}')

    return result


def main():
    params = {k: v for k, v in demisto.params().items() if v is not None}
    urls = get_params_by_indicator_type(**params)
    params['feed_name_to_config'] = {}
    for indicator_type in urls:
        params['feed_name_to_config'][indicator_type] = {
            'url': urls.get(indicator_type),
            'extractor': 'indicators[*].data',
            'indicator_type': FEED_INDICATOR_TYPES.get(indicator_type),
            'indicator': INDICATOR_VALUE_FIELD.get(indicator_type),
            'flat_json_with_prefix': True,
            'mapping': MAPPING.get(indicator_type),
            'build_iterator_paging': custom_build_iterator,
            'results_limit': DEFAULT_LIMIT
        }

    feed_main(params, 'Intel471 Malware Feed', 'intel471')


if __name__ in ('__main__', '__builtin__', 'builtins'):
    main()
